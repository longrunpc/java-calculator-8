# java-calculator-precourse

## 기능 요구 사항

입력한 문자열에서 숫자를 추출하여 더하는 계산기를 구현한다.

### 기본 구분자
- 쉼표(`,`) 또는 콜론(`:`)을 구분자로 가지는 문자열을 전달하는 경우 구분자를 기준으로 분리한 각 숫자의 합을 반환한다.

### 커스텀 구분자
- 기본 구분자(쉼표, 콜론) 외에 커스텀 구분자를 지정할 수 있다.
- 커스텀 구분자는 문자열 앞부분의 `"//"`와 `"\n"` 사이에 위치하는 문자를 커스텀 구분자로 사용한다.
- 예시: `"//;\n1;2;3"`과 같이 값을 입력할 경우 커스텀 구분자는 세미콜론(`;`)이며, 결과 값은 `6`이 반환되어야 한다.

### 예외 처리
- 사용자가 잘못된 값을 입력할 경우 `IllegalArgumentException`을 발생시킨 후 애플리케이션은 종료되어야 한다.

### 요구사항 구체화
#### 커스텀 구분자
- 문자열 앞부분의 `"//"`와 `"\n"` 사이에 위치하는 **문자**로 정의
- 따라서 문자열은 배제하고 단일 문자만 지원
- 커스텀 구분자와 기본 구분자 동시 사용 가능

#### 입력 검증
- 구분자와 **양수**로 구성된 문자열이므로 음수값, 0, 띄어쓰기 예외처리

---

## 입출력 요구 사항

### 입력
- 구분자와 양수로 구성된 문자열

### 출력
- 덧셈 결과
```
결과 : 6
```

## 실행 결과 예시

```
덧셈할 문자열을 입력해 주세요.
1,2:3
결과 : 6
```

---

## 프로젝트 구조

```
calculator/
├── Application.java (Main)
├── controller/
│   └── CalculatorController.java
├── service/
│   ├── CalculatorService.java (Interface)
│   └── CalculatorServiceImpl.java
├── model/
│   ├── parser/
│   │   ├── Parser.java (Interface)
│   │   └── DelimiterParser.java
│   └── calculator/
│       ├── Calculator.java (Interface)
│       └── PositiveNumberCalculator.java
├── view/
│   ├── input/
│   │   └── InputView.java
│   ├── output/
│   │   └── OutputView.java
│   └── validator/
│       └── InputValidator.java
└── common/
    └── ErrorMessages.java
```

### 레이어별 역할

#### View Layer
- **책임**: 사용자와의 입출력 인터페이스
- **InputView**: Console을 통한 사용자 입력
- **OutputView**: 계산 결과 및 에러 메시지 출력
- **InputValidator**: 입력값의 기본 형식 검증 (공백 체크)

#### Controller Layer
- **책임**: 애플리케이션 흐름 제어
- **CalculatorController**: View에서 입력을 받아 Service를 호출하고 결과를 View로 전달

#### Service Layer
- **책임**: 비즈니스 로직 조율 및 데이터 변환
- **CalculatorService**: Parser와 Calculator를 조합하여 문자열 입력을 계산 결과 문자열로 변환
- 데이터 흐름: `문자열 → 숫자 리스트 → 합계 → 문자열`

#### Model Layer
- **책임**: 핵심 비즈니스 로직
- **Parser**: 구분자 기반 문자열 파싱 (기본 구분자: `,` `:` / 커스텀 구분자: `//;\n`)
- **Calculator**: 숫자 리스트 합산 및 양수 검증 (0 이하 값 예외 처리)

#### Common
- **책임**: 공통 상수 및 유틸리티
- **ErrorMessages**: 애플리케이션 전역 에러 메시지 상수 관리

---

## 구현 기능 목록

### 1. View Layer
- [x] **InputView**: 사용자 입력 받기
- [x] **OutputView**: 결과 출력
- [x] **InputValidator**: 입력 검증 (공백 체크)

### 2. Controller Layer
- [x] **CalculatorController**: View ↔ Service 연결 및 흐름 제어

### 3. Service Layer
- [x] **CalculatorService**: model들을 조합하여 계산 수행

### 4. Model Layer
- [x] **Parser**: 문자열을 숫자 리스트로 파싱 (기본/커스텀 구분자 처리)
- [x] **Calculator**: 숫자 리스트 합산

### 5. Common
- [x] **ErrorMessages**: 에러 메시지 관리

### 6. Test
- [x] **ApplicationTest**: 통합 테스트
- [x] **ParserTest**: 파싱 단위 테스트
- [x] **CalculatorTest**: 계산 단위 테스트
- [x] **InputValidatorTest**: 입력 검증 단위 테스트

---

## 시나리오

```
1. 사용자 입력 (InputView)
   ↓
2. 입력 검증 (InputValidator)
   ↓
3. 계산 요청 (CalculatorController → CalculatorService)
   ↓
4. 문자열 파싱 (DelimiterParser)
   "1,2:3" → [1, 2, 3]
   ↓
5. 숫자 합산 (PositiveNumberCalculator)
   [1, 2, 3] → 6
   ↓
6. 결과 출력 (OutputView)
   "결과 : 6"
```

---

## 회고

- **확장성 중심 설계**

  이번 주차에서는 현재 요구사항을 충족하는 것에 그치지 않고, 앞으로 기능이 늘어나도 구조가 흔들리지 않도록 설계하는 데 집중하였습니다. 각 책임을 인터페이스로 분리하여 결합도를 낮추고 교체 가능성을 높이려고 하였습니다. 계산 로직은 `Calculator` 인터페이스로 추상화하고 `PositiveNumberCalculator`로 구현하여 양수 계산 요구사항을 충족하되, 다른 계산 규칙으로도 자연스럽게 확장할 수 있도록 하였습니다. 또한 숫자 범위가 커질 수 있는 상황을 고려하여 `BigInteger`를 사용함으로써 오버플로우 없이 안정적으로 동작하도록 하였습니다. 파싱 영역 역시 `Parser` 인터페이스와 `DelimiterParser` 구현으로 시작하였습니다.

- **균형 잡힌 네이밍**

  네이밍은 역할이 명확히 드러나면서도 향후 확장 시 충돌을 최소화할 수 있는 방향을 지향하였습니다. 예를 들어, `DelimiterParser`라는 이름은 현재 구현의 본질을 가장 명확하게 표현한다고 판단하여 선택했습니다. 또한, 추후 다른 구분자 파싱 방식이 추가될 가능성도 고려했지만, 결국 가장 직관적이고 일관된 표현이라는 점에서 이 명칭을 유지하기로 결정했습니다. 합계를 구하는 기능 역시 `calculateSum`으로 이후 다양한 합산 방식이 추가될 수 있음을 고려하여 오버로딩과 다형성으로 확장을 수용하는 전략을 함께 마련하였습니다. 이처럼 아직 부족하지만, 네이밍에 더 집중하며 가독성이 높은 코드를 작성하려는 개발자에 한 걸음 더 다가설 수 있었다고 생각합니다.

- **검증의 책임 경계**

  입력값 검증은 어느 계층에서 어느 수준으로 수행할지에 따라 코드의 성격이 크게 달라진다고 느꼈습니다. 사전 검증은 잘못된 데이터가 내부 로직에 도달하는 것을 방지하여 디버깅과 가독성 측면에서 이점이 있지만, 검증 코드가 과도해질 수 있는 단점도 있습니다. 반대로 내부 예외 중심의 접근은 흐름이 단순하지만, 예외 추적의 책임이 커질 수 있습니다. 이번 과제에서는 계층의 책임에 맞게 최소한의 중복으로 검증을 배치하는 것이 합리적이라는 결론에 도달하였습니다. 입력 단계에서는 기본 형식 검증을 수행하고, 내부에서는 예외 처리를 통해 안정성과 단순성의 균형을 맞추고자 하였습니다. 이러한 고민을 통해 검증 설계에 대한 시야를 넓힐 수 있었고, 추후 프로젝트를 진행할 때에도 더 깊이 있는 검증 로직 설계에 집중할 수 있는 계기가 되었습니다.

- **마무리**

  함수형 스타일(Stream)과 불변 객체를 적극적으로 활용하여 예측 가능성과 안정성을 높이려고 노력하였습니다. 비록 1주차이지만, 단순히 동작하는 코드를 넘어서 확장성과 책임 분리를 고민하며 과제를 완성한 경험이 의미 있었다고 생각합니다. 다음 주차에는 테스트 보강, 요구사항 정리의 명확화, 설계 의사결정 근거의 체계화, 그리고 저만의 클린 코드 규칙 정립에 더욱 집중하여 개선을 이어가겠습니다.

---